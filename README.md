| category                      | name                                           | notes                                                                                                                |
| ------------------------------- | ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| stack                         | valid parentheses                              | append openings to stack; if not stack and matching closing- pop(); return True if not stack                         |
| sort                          | valid anagram                                  | return sorted(a) == sorted(b)                                                                                        |
| map, str                      | group anagrams                                 | map res; for word: map[char freq]; return map.values                                                                 |
| map, arr                      | contains duplicate                             | nums len = set(nums) len? bc set returns list wo duplicates                                                          |
| map, arr                      | two sum                                        | one pass sol // map[val:idx]; if val in map; return [map[val], idx]; else map[val] = idx                             |
| map, 2po, str, sliding window | longest substring without repeating characters | set; for r in range(len(s)): while r in set: shift l; add r to set                                                   |
| dp, d&c, arr                  | maximum subarray                               | iterate thru arr; if l is -, reset curSum, curSum+=n; maxSub = max(l,curS)                                           |
| dp, arr                       | best time to buy and sell stock                | slider prob - two pointer sol // iterate thru arr: l=min(l, i), r=max(profit,maxP)                                   |
| dp                            | climbing stairs                                | recursion; n = n-1 + n-2 // memoization - save in map, possible paths                                                |
| dp                            | range sum query - immutable                    | create a running total in const // diff bw runTot[right+1] and runTot[left] is the sum                               |
| bp, arr                       | missing number                                 | exp sum - act sum // exp sum calc usin math formula                                                                  |
| bp                            | single number                                  | for num, out ^= num // (a^a=0 // 0^a=a)                                                                              |
| arr, sort                     | merge intervals                                | sort intervals by start time; if i[start] <= i-1[end] - end=max(i[end],i-1[end]) else append // think of number line |
| arr, 2po, greedy              | boats to save people                           | sort arr; left-lowest, right-highest; if sum <= limit: count++; else shift right, count++ (send right alone)         |
| arr, 2po                      | container with most water                      | while l < r: mA = max(mA,area); if r > l: shift l else r                                                             |
| arr, 2po                      | two sum 2 - input arr is sorter                | if sum < target, shift left else right                                                                               |
| arr, 2po                      | 3sum                                           | sort arr; iterate a, if +1 ==, continue; 2sum on rest (2po)                                                          |
| arr, 2po                      | move zeroes                                    | j = 0; if n not 0, nums[j] = n; j+=1; nums[j,end] = 0                                                                |
| arr                           | product of array except self                   | two passes; one in order for prefixes, one in reverse for postfixes while computing products                         |
| arr                           | find all numbers disappeared in an array       | mark indices[val-1] in list as - // return pos[ind+1] of + nums                                                      |
| arr                           | valid mountain array                           | 2 loops // first loop breaks at peak, perform checks; second from peak to end, perform checks                        |
